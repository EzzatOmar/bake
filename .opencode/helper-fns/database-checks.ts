import path from "node:path";
import { fileLog } from "./file-logger";
import { isTestFile } from "./path-checks";


/**
 * Helper to extract just the filename from a path, handling both Unix and Windows paths
 */
function getFileName(filePath: string): string {
    // Normalize path separators to forward slashes
    const normalizedPath = filePath.replace(/\\/g, "/");
    // Get the last part (filename)
    const parts = normalizedPath.split("/");
    const fileName = parts[parts.length - 1];
    // Remove .ts extension
    return fileName.replace(/\.ts$/, "");
}

/**
 * Check if the file is a schema.better-auth.<dbname>.ts file
 */
function isBetterAuthSchema(filePath: string): boolean {
    const fileName = getFileName(filePath);
    return fileName.includes("schema.better-auth.");
}

/**
 * Rule: schema.better-auth.<dbname>.ts files are autogenerated and should not be edited directly
 * Users should edit auth.<dbname>.ts instead and run migrations
 */
export function assertNotBetterAuthSchema(args: { directory: string, filePath: string }) {
    if (isBetterAuthSchema(args.filePath)) {
        const fileName = getFileName(args.filePath);
        
        // Extract dbname from the filename
        const dbName = fileName.replace("schema.better-auth.", "");
        
        fileLog("assertNotBetterAuthSchema", "attempted to edit autogenerated file", fileName);
        throw new Error(
            "AUTOGENERATED FILE. DO NOT EDIT. " +
            `The file ${fileName}.ts is automatically generated by better-auth CLI. ` +
            `To modify the better-auth schema, edit auth.${dbName}.ts and run migrations manually:\n\n` +
            "```bash\n" +
            `bunx --bun @better-auth/cli@latest generate --config=src/database/${dbName}/auth.${dbName}.ts --output=src/database/${dbName}/schema.better-auth.${dbName}.ts --yes\n` +
            `bunx drizzle-kit generate --config=drizzle.${dbName}.ts\n` +
            `bunx drizzle-kit migrate --config=drizzle.${dbName}.ts\n` +
            "```"
        );
    }
}

/**
 * Rule: Only conn.<dbname>.ts, schema.<type>.<dbname>.ts, and auth.<dbname>.ts files are allowed in src/database/<dbname>/
 * All other files (queries, helpers, utils) should go in src/function/
 */
export function assertDatabaseFileName(args: { directory: string, filePath: string }) {
    const fileName = getFileName(args.filePath);
    
    const isConn = fileName.startsWith("conn.");
    const isSchema = fileName.startsWith("schema.");
    const isAuth = fileName.startsWith("auth.");
    
    if (!isConn && !isSchema && !isAuth) {
        fileLog("assertDatabaseFileName", "invalid database file name", fileName);
        throw new Error(
            "Only 'conn.<dbname>.ts', 'schema.<type>.<dbname>.ts', and 'auth.<dbname>.ts' files are allowed in src/database/<dbname>/. " +
            `Found: ${fileName}.ts. ` +
            "Database queries and helper functions should be placed in src/function/ directory. " +
            "The function-builder subagent can help you create properly structured functions. " +
            "You might want to read .opencode/agent/function-builder.md"
        );
    }
}

/**
 * Rule: Database files must follow the naming pattern:
 * - conn.<dbname>.ts
 * - schema.<type>.<dbname>.ts (e.g., schema.custom.<dbname>.ts, schema.better-auth.<dbname>.ts)
 * - auth.<dbname>.ts
 * where <dbname> matches the parent directory name
 */
export function assertDatabaseFileNameMatchesDirectory(args: { directory: string, filePath: string }) {
    const fileName = getFileName(args.filePath);
    
    // Normalize both paths to forward slashes for cross-platform compatibility
    const normalizedDirectory = args.directory.replace(/\\/g, "/");
    const normalizedFilePath = args.filePath.replace(/\\/g, "/");
    
    // Get relative path from directory
    const relativePath = normalizedFilePath.replace(normalizedDirectory + "/", "");
    const pathParts = relativePath.split("/");
    
    if (pathParts.length < 3 || pathParts[0] !== "src" || pathParts[1] !== "database") {
        return; // Not in database folder, skip this check
    }
    
    const dbName = pathParts[2];
    
    // Check if fileName matches allowed patterns
    const isValidConn = fileName === `conn.${dbName}`;
    const isValidAuth = fileName === `auth.${dbName}`;
    // Schema files can have a type in between: schema.<type>.<dbname>
    const isValidSchema = fileName.startsWith("schema.") && fileName.endsWith(`.${dbName}`);
    
    if (!isValidConn && !isValidAuth && !isValidSchema) {
        fileLog("assertDatabaseFileNameMatchesDirectory", "file name doesn't match directory", {
            fileName,
            dbName,
        });
        throw new Error(
            `Database file name must match the directory name. ` +
            `Expected patterns: conn.${dbName}.ts, auth.${dbName}.ts, or schema.<type>.${dbName}.ts. ` +
            `Found: ${fileName}.ts in src/database/${dbName}/. ` +
            "You might want to read .opencode/agent/database-manager.md"
        );
    }
}

/**
 * Rule: Database files must be exactly at src/database/<dbname>/<file>.ts
 * No subdirectories allowed
 */
export function assertDatabasePathDepth(args: { directory: string, filePath: string }) {
    // Normalize both paths to forward slashes for cross-platform compatibility
    const normalizedDirectory = args.directory.replace(/\\/g, "/");
    const normalizedFilePath = args.filePath.replace(/\\/g, "/");
    
    // Get relative path from directory
    const relativePath = normalizedFilePath.replace(normalizedDirectory + "/", "");
    const pathParts = relativePath.split("/");
    
    // Expected structure: src/database/<dbname>/<file>.ts = 4 parts
    if (pathParts.length !== 4) {
        fileLog("assertDatabasePathDepth", "invalid path depth", {
            pathParts,
            depth: pathParts.length
        });
        throw new Error(
            "Database files must be at src/database/<dbname>/<file>.ts. " +
            "No subdirectories or additional nesting allowed. " +
            `Found: ${relativePath}. ` +
            "You might want to read .opencode/agent/database-manager.md"
        );
    }
}

/**
 * Check if file is in database folder
 */
function isDatabaseFolder(args: { directory: string, filePath: string }): boolean {
    const relativePath = path.relative(args.directory, args.filePath);
    if (!relativePath.startsWith("src/database/")) {
        return false;
    }
    return true;
}


// ===== COMBINED CHECK FUNCTIONS =====

export async function checkDbBeforeWrite(args: { directory: string, content: string, filePath: string }) {
    if (!isDatabaseFolder(args)) return;
    if (isTestFile(args)) return;
    
    assertNotBetterAuthSchema(args);
    assertDatabaseFileName(args);
    assertDatabaseFileNameMatchesDirectory(args);
    assertDatabasePathDepth(args);
}

export async function checkDbBeforeEdit(args: { directory: string, content: string, filePath: string }) {
    if (!isDatabaseFolder(args)) return;
    if (isTestFile(args)) return;
    
    assertNotBetterAuthSchema(args);
    assertDatabaseFileName(args);
    assertDatabaseFileNameMatchesDirectory(args);
    assertDatabasePathDepth(args);
}

export async function checkDbAfterWrite(args: { directory: string, content: string, filePath: string }) {
    if (!isDatabaseFolder(args)) return;
    if (isTestFile(args)) return;
    
    // For database files, we only need path-based checks
    // No content analysis required since we're just ensuring proper file structure
    assertDatabaseFileName(args);
    assertDatabaseFileNameMatchesDirectory(args);
    assertDatabasePathDepth(args);
}

export async function checkDbAfterEdit(args: { directory: string, content: string, filePath: string }) {
    if (!isDatabaseFolder(args)) return;
    if (isTestFile(args)) return;
    
    // For database files, we only need path-based checks
    // No content analysis required since we're just ensuring proper file structure
    assertDatabaseFileName(args);
    assertDatabaseFileNameMatchesDirectory(args);
    assertDatabasePathDepth(args);
}
