#!/usr/bin/env bun
import { $ } from "bun";
import path from "node:path";
import { getDatabaseVariableNames } from "../helper-fns/get-db-names";
import { addAuthToRouter } from "../helper-fns/add-auth-to-router";
import { existsSync } from "fs";

const dbName = process.argv[2];
const projectRoot = path.resolve(import.meta.dir, '../../');
const dbNames = await getDatabaseVariableNames(projectRoot).then(names => names.map(n => n.substring(0, n.length - 2)));

if (!dbName) {
  console.error(`Usage: bun run install-better-auth.ts <db-name> \n Must be one of: ${dbNames.join(', ')}`);
  process.exit(1);
}

if (!dbNames.includes(dbName)) {
  console.error(`Database ${dbName} not found. Must be one of: ${dbNames.join(', ')}`);
  process.exit(1);
}

const authServerFile = `// https://www.better-auth.com/docs/basic-usage
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { ${dbName}Db } from "./conn.${dbName}.ts";

export const auth = betterAuth({
  database: drizzleAdapter(${dbName}Db, {
    provider: "sqlite",
  }), 
  emailAndPassword: {
    enabled: true,
  },
});
`;

await writeFile(path.join(projectRoot, "src/database", dbName, `auth.${dbName}.ts`), authServerFile, "utf8");
console.log(`Created auth file: src/database/${dbName}/auth.${dbName}.ts`);

// Run drizzle-kit generate
const drizzleConfig = `drizzle.${dbName}.ts`;

// Generate better-auth schema with temporary filename
const tempSchemaFile = path.join(projectRoot, "src/database", dbName, `schema.auth.${dbName}.ts`);
const finalSchemaFile = path.join(projectRoot, "src/database", dbName, `schema.better-auth.${dbName}.ts`);

await $`bunx --bun @better-auth/cli@latest generate --config=src/database/${dbName}/auth.${dbName}.ts --output=${tempSchemaFile} --yes`.cwd(projectRoot);

// Rename the file from schema.auth to schema.better-auth
import { rename } from "node:fs/promises";
await rename(tempSchemaFile, finalSchemaFile);
console.log(`Renamed schema file to: src/database/${dbName}/schema.better-auth.${dbName}.ts`);

await $`bunx drizzle-kit generate --config=${drizzleConfig}`.cwd(projectRoot);
await $`bunx drizzle-kit migrate --config=${drizzleConfig}`.cwd(projectRoot);

// Add autogeneration warning header to the schema file
import { readFile, writeFile, mkdir } from "node:fs/promises";

let schemaContent = await readFile(finalSchemaFile, "utf8");

const warningHeader = `/**
 * AUTOGENERATED FILE. DO NOT EDIT.
 * 
 * This file is automatically generated by better-auth CLI.
 * To modify the better-auth schema, edit auth.${dbName}.ts and run migrations manually:
 * 
 * \`\`\`bash
 * bunx --bun @better-auth/cli@latest generate --config=src/database/${dbName}/auth.${dbName}.ts --output=src/database/${dbName}/schema.better-auth.${dbName}.ts --yes
 * bunx drizzle-kit generate --config=drizzle.${dbName}.ts
 * bunx drizzle-kit migrate --config=drizzle.${dbName}.ts
 * \`\`\`
 * 
 * If you want to edit other tables, edit the schema.custom.${dbName}.ts file instead.
 */

`;

schemaContent = warningHeader + schemaContent;
await writeFile(finalSchemaFile, schemaContent, "utf8");
console.log(`Added autogeneration warning to schema file`);

// After running auth codegen, also update the connection file to combine authSchema.
// Replace "const schema = customSchema;" with "const schema = { ...authSchema, ...customSchema };"
const connFile = path.join(
  projectRoot,
  "src/database",
  dbName,
  `conn.${dbName}.ts`
);

let connContent = await readFile(connFile, "utf8");

const regex = /const\s+schema\s*=\s*customSchema\s*;/;
if (regex.test(connContent)) {
  connContent = connContent.replace(
    regex,
    "import * as authSchema from './schema.better-auth." + dbName + ".ts';\nconst schema = { ...authSchema, ...customSchema };"
  );
  await writeFile(connFile, connContent, "utf8");
  console.log(`Updated "${connFile}": combined authSchema and customSchema.`);
} else {
  console.log(
    `Notice: Did not find "const schema = customSchema;" in ${connFile}. Skipped automatic replacement.`
  );
}

// Create middleware function for session resolution
const errorCode = `FX_${dbName.toUpperCase()}_SESSION_NOT_FOUND`;

const middlewareContent = `import type { auth } from "@/src/database/${dbName}/auth.${dbName}.ts"
import { ErrCode } from "@/src/error/err.enum";

export type TPortal = {
    auth: typeof auth;
}

export type TArgs = {
    headers: Headers;
}

export type TAuthSession = {
    session: {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        userId: string;
        expiresAt: Date;
        token: string;
        ipAddress?: string | null | undefined;
        userAgent?: string | null | undefined;
    }
    user: {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        email: string;
        emailVerified: boolean;
        name: string;
    }
}


export async function fxResolveSession(portal: TPortal, args: TArgs): Promise<TErrTuple<TAuthSession>> {
  let authSession:TAuthSession | null = await portal.auth.api.getSession(args);

  if(!authSession) {
    return [null, {
        code: ErrCode.${errorCode},
        statusCode: 401,
        externalMessage: { en: 'Session not found', de: 'Sitzung nicht gefunden', fr: 'Session non trouv√©e' },
        internalMessage: 'Session not found',
    }];
  }

  return [authSession, null];
}
`;

const middlewareDir = path.join(projectRoot, "src/function/middleware");
const middlewareFile = path.join(middlewareDir, `fx.${dbName}-session.ts`);

// Ensure middleware directory exists
await mkdir(middlewareDir, { recursive: true });

await writeFile(middlewareFile, middlewareContent, "utf8");
console.log(`Created middleware file: src/function/middleware/fx.${dbName}-session.ts`);

// Update error enum file
const errEnumFile = path.join(projectRoot, "src/error/err.enum.ts");
let errEnumContent = await readFile(errEnumFile, "utf8");

// Check if error code already exists
if (!errEnumContent.includes(errorCode)) {
  // Find the last enum entry before the closing brace
  const enumPattern = /(export enum ErrCode \{[\s\S]*?)([\s]*\})/;
  const match = errEnumContent.match(enumPattern);
  
  if (match) {
    // Insert the new error code before the closing brace
    // Add a comma to the previous line if it doesn't have one
    let enumBody = match[1];
    const lastCommaIndex = enumBody.lastIndexOf(',');
    const lastSemicolonIndex = enumBody.lastIndexOf(';');
    const closingBraceIndex = enumBody.lastIndexOf('\n');
    
    // If the last line doesn't end with a comma, add one
    if (lastCommaIndex < closingBraceIndex && lastSemicolonIndex < closingBraceIndex) {
      const lastLineBreak = enumBody.lastIndexOf('\n', closingBraceIndex - 1);
      if (lastLineBreak !== -1) {
        const beforeLastLine = enumBody.substring(0, lastLineBreak);
        const lastLine = enumBody.substring(lastLineBreak, closingBraceIndex);
        
        // Only add comma if the line has content and doesn't already have a comma
        if (lastLine.trim() && !lastLine.includes(',')) {
          enumBody = beforeLastLine + lastLine.trimEnd() + ',\n';
        }
      }
    }
    
    const newEnumContent = enumBody + `\n  ${errorCode},\n` + match[2];
    errEnumContent = errEnumContent.replace(enumPattern, newEnumContent);
    
    await writeFile(errEnumFile, errEnumContent, "utf8");
    console.log(`Added error code "${errorCode}" to src/error/err.enum.ts`);
  } else {
    console.error(`Could not parse error enum file. Please manually add: ${errorCode}`);
  }
} else {
  console.log(`Error code "${errorCode}" already exists in err.enum.ts`);
}

// Add auth handler to router
console.log('\nüîß Adding auth handler to router...');
const indexTsxPath = path.join(projectRoot, "src/index.tsx");
const indexTsPath = path.join(projectRoot, "src/index.ts");

let indexPath: string | null = null;
if (existsSync(indexTsxPath)) {
  indexPath = indexTsxPath;
} else if (existsSync(indexTsPath)) {
  indexPath = indexTsPath;
}

if (indexPath) {
  const result = addAuthToRouter(indexPath, dbName);
  if (result.success) {
    console.log(`‚úÖ ${result.message}`);
  } else {
    // Add comment at top of file indicating this better-auth instance is not added
    const commentToAdd = `// NOTE: better-auth for database "${dbName}" is installed but not added to router.\n// ${result.message}\n// Import: import { auth } from "@/src/database/${dbName}/auth.${dbName}";\n// Route: "/api/auth/*": auth.handler,\n\n`;
    
    let indexContent = await readFile(indexPath, "utf8");
    
    // Check if comment already exists
    if (!indexContent.includes(`better-auth for database "${dbName}"`)) {
      indexContent = commentToAdd + indexContent;
      await writeFile(indexPath, indexContent, "utf8");
      console.log(`‚ö†Ô∏è  ${result.message}`);
      console.log(`üìù Added comment to ${path.basename(indexPath)} with manual setup instructions`);
    } else {
      console.log(`‚ÑπÔ∏è  Comment already exists in ${path.basename(indexPath)}`);
    }
  }
} else {
  console.log('‚ö†Ô∏è  src/index.tsx or src/index.ts not found, skipping router update');
  console.log('üìù Please manually add the following to your router:');
  console.log(`   Import: import { auth } from "@/src/database/${dbName}/auth.${dbName}";`);
  console.log(`   Route: "/api/auth/*": auth.handler,`);
}

console.log('\n‚úÖ Better-auth installation completed!');
console.log('\nüìã Files created/updated:');
console.log(`   - src/database/${dbName}/auth.${dbName}.ts`);
console.log(`   - src/database/${dbName}/schema.better-auth.${dbName}.ts`);
console.log(`   - src/database/${dbName}/conn.${dbName}.ts (updated)`);
console.log(`   - src/function/middleware/fx.${dbName}-session.ts`);
console.log(`   - src/error/err.enum.ts (updated)`);
if (indexPath) {
  console.log(`   - ${path.relative(projectRoot, indexPath)} (router updated)`);
}

